/**
 * Component Consolidation Script
 * 
 * This script helps in consolidating similar components based on the
 * consolidation plan generated by the analyze-similar-components.js script.
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { execSync } from 'child_process';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Default paths
const PLAN_PATH = path.join(process.cwd(), 'reports/consolidation-plan.json');
const BACKUP_DIR = path.join(process.cwd(), 'backups/pre-consolidation-' + Date.now());

// Configuration options
const CONFIG = {
  // Whether to update import paths in files that import the consolidated components
  updateImportPaths: true,
  
  // Whether to create a backup before consolidation
  createBackup: true,
  
  // Whether to delete the original component files that were consolidated
  deleteOriginals: false,  // Default to false for safety
  
  // Whether to add deprecation notices to the original components
  addDeprecationNotices: true,
  
  // Index to start consolidation from (if you want to resume a partially completed run)
  startIndex: 0,
  
  // Maximum number of components to consolidate in one run (0 for all)
  maxToConsolidate: 0
};

/**
 * Create a backup of the components directory
 */
function createBackup() {
  console.log(`Creating backup in ${BACKUP_DIR}...`);
  
  // Ensure backup directory exists
  if (!fs.existsSync(BACKUP_DIR)) {
    fs.mkdirSync(BACKUP_DIR, { recursive: true });
  }
  
  // Copy components directory to backup
  const componentsDir = path.join(process.cwd(), 'client/src/components');
  
  try {
    execSync(`cp -r ${componentsDir}/* ${BACKUP_DIR}/`, { stdio: 'inherit' });
    console.log('Backup created successfully');
    return true;
  } catch (error) {
    console.error('Error creating backup:', error);
    return false;
  }
}

/**
 * Load the consolidation plan from the specified file
 */
function loadConsolidationPlan(planPath = PLAN_PATH) {
  try {
    if (!fs.existsSync(planPath)) {
      console.error(`Consolidation plan not found at ${planPath}`);
      return null;
    }
    
    const planData = fs.readFileSync(planPath, 'utf8');
    return JSON.parse(planData);
  } catch (error) {
    console.error('Error loading consolidation plan:', error);
    return null;
  }
}

/**
 * Extract all imports from a component file
 */
function extractImports(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const imports = [];
    const importRegex = /import\s+(?:{([^}]+)}\s+from\s+|([^\s]+)\s+from\s+)['"]([^'"]+)['"]/g;
    let match;
    
    while ((match = importRegex.exec(content)) !== null) {
      const namedImports = match[1] ? match[1].trim().split(/\s*,\s*/) : [];
      const defaultImport = match[2] ? match[2].trim() : null;
      const importPath = match[3];
      
      imports.push({
        statement: match[0],
        namedImports: namedImports.map(imp => {
          const parts = imp.split(/\s+as\s+/);
          return { name: parts[0].trim(), alias: parts[1] ? parts[1].trim() : null };
        }),
        defaultImport,
        path: importPath
      });
    }
    
    return imports;
  } catch (error) {
    console.error(`Error extracting imports from ${filePath}:`, error);
    return [];
  }
}

/**
 * Extract the component definition from a file
 */
function extractComponentDefinition(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    
    // Remove imports from the beginning
    const withoutImports = content.replace(/import\s+.*?from\s+['"].*?['"];?\s*/g, '');
    
    // Find the component definition
    // Support both function components and class components
    const functionMatch = withoutImports.match(/(export\s+(?:default\s+)?function\s+\w+.*?\{[\s\S]*)/);
    const constMatch = withoutImports.match(/(export\s+(?:default\s+)?const\s+\w+\s*=.*?\{[\s\S]*)/);
    const classMatch = withoutImports.match(/(export\s+(?:default\s+)?class\s+\w+.*?\{[\s\S]*)/);
    
    const match = functionMatch || constMatch || classMatch;
    
    if (match) {
      return match[1];
    }
    
    return null;
  } catch (error) {
    console.error(`Error extracting component definition from ${filePath}:`, error);
    return null;
  }
}

/**
 * Extract the component name from a file
 */
function extractComponentName(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    
    // Try to find the component name
    const functionMatch = content.match(/export\s+(?:default\s+)?function\s+(\w+)/);
    const constMatch = content.match(/export\s+(?:default\s+)?const\s+(\w+)\s*=/);
    const classMatch = content.match(/export\s+(?:default\s+)?class\s+(\w+)/);
    
    const match = functionMatch || constMatch || classMatch;
    
    if (match) {
      return match[1];
    }
    
    return path.basename(filePath, path.extname(filePath));
  } catch (error) {
    console.error(`Error extracting component name from ${filePath}:`, error);
    return path.basename(filePath, path.extname(filePath));
  }
}

/**
 * Find files that import a specific component
 */
function findFilesThatImport(componentPath, componentName) {
  const componentsDir = path.join(process.cwd(), 'client/src');
  const result = [];
  
  function traverse(dir) {
    const files = fs.readdirSync(dir);
    
    files.forEach(file => {
      const filePath = path.join(dir, file);
      const stat = fs.statSync(filePath);
      
      if (stat.isDirectory() && !file.startsWith('.')) {
        traverse(filePath);
      } else if (stat.isFile() && 
                ['.tsx', '.jsx', '.ts', '.js'].includes(path.extname(file))) {
        try {
          const content = fs.readFileSync(filePath, 'utf8');
          
          // Check if this file imports the component
          const relativeComponentPath = path.relative(
            path.dirname(filePath), 
            componentPath
          ).replace(/\\/g, '/');
          
          // Adjust for index files
          const importPaths = [
            path.dirname(relativeComponentPath),
            relativeComponentPath.replace(/\.\w+$/, ''),
            relativeComponentPath
          ];
          
          // Check for various import patterns
          const importPatterns = importPaths.map(p => {
            // Handle paths that need to go up directories
            if (!p.startsWith('.')) {
              p = './' + p;
            }
            return `from ['"]${p.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}['"]`;
          });
          
          const importRegex = new RegExp(importPatterns.join('|'), 'g');
          
          if (importRegex.test(content) && filePath !== componentPath) {
            // Also check that it actually imports the component name
            const namedImportRegex = new RegExp(`{[^}]*\\b${componentName}\\b[^}]*}\\s+from`, 'g');
            const defaultImportRegex = new RegExp(`import\\s+${componentName}\\s+from`, 'g');
            
            if (namedImportRegex.test(content) || defaultImportRegex.test(content)) {
              result.push(filePath);
            }
          }
        } catch (error) {
          console.error(`Error checking imports in ${filePath}:`, error);
        }
      }
    });
  }
  
  traverse(componentsDir);
  return result;
}

/**
 * Update import paths in files that import consolidated components
 */
function updateImportPathsInFiles(files, originalPath, targetPath, componentName) {
  let updatedCount = 0;
  
  files.forEach(filePath => {
    try {
      let content = fs.readFileSync(filePath, 'utf8');
      const originalContent = content;
      
      // Calculate relative paths from this file to both the original and target components
      const fileDir = path.dirname(filePath);
      const relativeOriginalPath = path.relative(fileDir, originalPath).replace(/\\/g, '/');
      const relativeTargetPath = path.relative(fileDir, targetPath).replace(/\\/g, '/');
      
      // Ensure paths start with ./ or ../
      const formattedOriginalPath = relativeOriginalPath.startsWith('.') 
        ? relativeOriginalPath : './' + relativeOriginalPath;
      const formattedTargetPath = relativeTargetPath.startsWith('.') 
        ? relativeTargetPath : './' + relativeTargetPath;
      
      // Remove file extension for import paths
      const importOriginalPath = formattedOriginalPath.replace(/\.\w+$/, '');
      const importTargetPath = formattedTargetPath.replace(/\.\w+$/, '');
      
      // Update named imports
      const namedImportRegex = new RegExp(
        `(import\\s+{[^}]*\\b)(${componentName})(\\b[^}]*}\\s+from\\s+['"])${importOriginalPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(['"])`, 
        'g'
      );
      
      content = content.replace(namedImportRegex, `$1$2$3${importTargetPath}$5`);
      
      // Update default imports
      const defaultImportRegex = new RegExp(
        `(import\\s+)(${componentName})(\\s+from\\s+['"])${importOriginalPath.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}(['"])`, 
        'g'
      );
      
      content = content.replace(defaultImportRegex, `$1$2$3${importTargetPath}$5`);
      
      // Only write if content has changed
      if (content !== originalContent) {
        fs.writeFileSync(filePath, content);
        updatedCount++;
        console.log(`  Updated import paths in: ${path.relative(process.cwd(), filePath)}`);
      }
    } catch (error) {
      console.error(`Error updating import paths in ${filePath}:`, error);
    }
  });
  
  return updatedCount;
}

/**
 * Add a deprecation notice to the original component
 */
function addDeprecationNotice(filePath, targetPath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const targetComponent = path.basename(targetPath);
    const relativeTargetPath = path.relative(path.dirname(filePath), targetPath).replace(/\\/g, '/');
    const importTargetPath = relativeTargetPath.startsWith('.') 
      ? relativeTargetPath.replace(/\.\w+$/, '') 
      : './' + relativeTargetPath.replace(/\.\w+$/, '');
    
    const componentName = extractComponentName(filePath);
    
    // Create the deprecation notice
    const deprecationNotice = `/**
 * @deprecated This component has been consolidated with ${targetComponent}.
 * Please use the component from ${importTargetPath} instead.
 */
import { ${componentName} } from '${importTargetPath}';
export { ${componentName} };
export default ${componentName};
`;
    
    fs.writeFileSync(filePath, deprecationNotice);
    console.log(`  Added deprecation notice to: ${path.relative(process.cwd(), filePath)}`);
    
    return true;
  } catch (error) {
    console.error(`Error adding deprecation notice to ${filePath}:`, error);
    return false;
  }
}

/**
 * Merge a component into the target component
 */
function mergeComponentIntoTarget(sourcePath, targetPath) {
  try {
    // Read both components
    const sourceContent = fs.readFileSync(sourcePath, 'utf8');
    let targetContent = fs.readFileSync(targetPath, 'utf8');
    
    // Extract imports from both components
    const sourceImports = extractImports(sourcePath);
    const targetImports = extractImports(targetPath);
    
    // Extract component names
    const sourceName = extractComponentName(sourcePath);
    const targetName = extractComponentName(targetPath);
    
    // Extract component definitions
    const sourceDefinition = extractComponentDefinition(sourcePath);
    
    if (!sourceDefinition) {
      console.error(`Could not extract component definition from ${sourcePath}`);
      return false;
    }
    
    // Merge imports: Add any imports from source that aren't in target
    const newImports = [];
    
    sourceImports.forEach(sourceImport => {
      const hasMatchingImport = targetImports.some(targetImport => 
        targetImport.path === sourceImport.path
      );
      
      if (!hasMatchingImport) {
        newImports.push(sourceImport.statement);
      }
    });
    
    // Add new imports to the beginning of the target file
    if (newImports.length > 0) {
      targetContent = newImports.join('\n') + '\n\n' + targetContent;
    }
    
    // Add the source component definition to the target file
    // Rename it to avoid naming conflicts
    const renamedSourceDefinition = sourceDefinition
      .replace(new RegExp(`\\b${sourceName}\\b`, 'g'), `${sourceName}Original`)
      .replace(/export\s+default\s+/, '')
      .replace(/export\s+/, '');
    
    // Add a comment about the merged component
    const mergeComment = `\n\n/**
 * Original ${sourceName} component merged from: ${path.relative(process.cwd(), sourcePath)}
 * Merge date: ${new Date().toISOString().split('T')[0]}
 */\n`;
    
    // Add the renamed component to the end of the file, before the last export
    const lastExportIndex = targetContent.lastIndexOf('export default');
    
    if (lastExportIndex !== -1) {
      // Insert before the last export
      targetContent = 
        targetContent.slice(0, lastExportIndex) + 
        mergeComment + 
        renamedSourceDefinition + 
        '\n\n' + 
        targetContent.slice(lastExportIndex);
    } else {
      // Just append to the end
      targetContent += mergeComment + renamedSourceDefinition;
    }
    
    // Write the updated target file
    fs.writeFileSync(targetPath, targetContent);
    console.log(`  Merged ${sourceName} into ${targetName}`);
    
    return true;
  } catch (error) {
    console.error(`Error merging component ${sourcePath} into ${targetPath}:`, error);
    return false;
  }
}

/**
 * Consolidate components based on the plan
 */
function consolidateComponents(plan) {
  const totalToConsolidate = CONFIG.maxToConsolidate > 0 
    ? Math.min(CONFIG.maxToConsolidate, plan.length - CONFIG.startIndex)
    : plan.length - CONFIG.startIndex;
  
  console.log(`\nStarting consolidation of ${totalToConsolidate} component groups...`);
  
  // Create a backup if configured
  if (CONFIG.createBackup) {
    const backupSuccess = createBackup();
    if (!backupSuccess) {
      console.error('Failed to create backup. Aborting consolidation for safety.');
      return false;
    }
  }
  
  // Process each consolidation entry
  let consolidatedCount = 0;
  
  for (let i = CONFIG.startIndex; i < plan.length; i++) {
    if (CONFIG.maxToConsolidate > 0 && consolidatedCount >= CONFIG.maxToConsolidate) {
      break;
    }
    
    const entry = plan[i];
    console.log(`\nProcessing consolidation ${i + 1}/${plan.length}: ${entry.targetComponent.name}`);
    
    const targetPath = entry.targetComponent.path;
    console.log(`Target component: ${path.relative(process.cwd(), targetPath)}`);
    
    // Skip if target doesn't exist
    if (!fs.existsSync(targetPath)) {
      console.error(`Target component not found: ${targetPath}`);
      continue;
    }
    
    let successfulMerges = 0;
    
    // Process each component to merge
    entry.componentsToMerge.forEach(component => {
      const sourcePath = component.path;
      console.log(`Processing component to merge: ${path.relative(process.cwd(), sourcePath)}`);
      
      // Skip if source doesn't exist
      if (!fs.existsSync(sourcePath)) {
        console.error(`Source component not found: ${sourcePath}`);
        return;
      }
      
      // Get the component name
      const componentName = extractComponentName(sourcePath);
      
      // Find files that import this component
      const filesUsingComponent = findFilesThatImport(sourcePath, componentName);
      console.log(`  Found ${filesUsingComponent.length} files using this component`);
      
      // Merge the component into the target
      const mergeSuccess = mergeComponentIntoTarget(sourcePath, targetPath);
      
      if (mergeSuccess) {
        successfulMerges++;
        
        // Update import paths if configured
        if (CONFIG.updateImportPaths && filesUsingComponent.length > 0) {
          const updatedCount = updateImportPathsInFiles(
            filesUsingComponent, 
            sourcePath, 
            targetPath, 
            componentName
          );
          console.log(`  Updated import paths in ${updatedCount} files`);
        }
        
        // Add deprecation notice to original if configured
        if (CONFIG.addDeprecationNotices) {
          addDeprecationNotice(sourcePath, targetPath);
        }
        
        // Delete original if configured
        if (CONFIG.deleteOriginals) {
          try {
            fs.unlinkSync(sourcePath);
            console.log(`  Deleted original component: ${path.relative(process.cwd(), sourcePath)}`);
          } catch (error) {
            console.error(`  Error deleting original component ${sourcePath}:`, error);
          }
        }
      }
    });
    
    if (successfulMerges > 0) {
      consolidatedCount++;
      console.log(`Consolidated ${successfulMerges} components into ${path.basename(targetPath)}`);
    }
  }
  
  console.log(`\nConsolidation complete! Processed ${consolidatedCount} component groups.`);
  return true;
}

/**
 * Main function
 */
async function main() {
  console.log('Component Consolidation Script');
  console.log('=============================');
  console.log('Configuration:');
  Object.entries(CONFIG).forEach(([key, value]) => {
    console.log(`  ${key}: ${value}`);
  });
  
  // Load the consolidation plan
  const plan = loadConsolidationPlan();
  
  if (!plan || plan.length === 0) {
    console.error('No valid consolidation plan found. Run analyze-similar-components.js first.');
    return;
  }
  
  console.log(`Loaded consolidation plan with ${plan.length} component groups`);
  
  // Process the plan
  consolidateComponents(plan);
  
  console.log('\nDone!');
}

// Run the script
main().catch(err => {
  console.error('Error executing script:', err);
});